# Tests of Skylark 'int'

load("assert.sky", "assert")

# basic arithmetic
assert.eq(0 - 1, -1)
assert.eq(0 + 1, +1)
assert.eq(1 + 1, 2)
assert.eq(5 + 7, 12)
assert.eq(5 * 7, 35)
assert.eq(5 - 7, -2)

# truth
assert.true(123)
assert.true(-1)
assert.true(not 0)

# floored division
# (For real division, see float.sky.)
assert.eq(100 // 7, 14)
assert.eq(100 // -7, -15)
assert.eq(-100 // 7, -15) # NB: different from Go/Java
assert.eq(-100 // -7, 14) # NB: different from Go/Java
assert.eq(98 // 7, 14)
assert.eq(98 // -7, -14)
assert.eq(-98 // 7, -14)
assert.eq(-98 // -7, 14)

# remainder
assert.eq(100 % 7, 2)
assert.eq(100 % -7, -5) # NB: different from Go/Java
assert.eq(-100 % 7, 5) # NB: different from Go/Java
assert.eq(-100 % -7, -2)
assert.eq(98 % 7, 0)
assert.eq(98 % -7, 0)
assert.eq(-98 % 7, 0)
assert.eq(-98 % -7, 0)

# compound assignment
def compound():
  x = 1
  x += 1
  assert.eq(x, 2)
  x -= 3
  assert.eq(x, -1)
  x *= 39
  assert.eq(x, -39)
  x //= 4
  assert.eq(x, -10)
  x /= -2
  assert.eq(x, 5)
  x %= 3
  assert.eq(x, 2)

compound()

# int conversion
# See float.sky for float-to-int conversions.
# We follow Python 3 here, but I can't see the method in its madness.
# int from bool/int/float
assert.eq(int(False), 0)
assert.eq(int(True), 1)
assert.eq(int(3), 3)
assert.eq(int(3.1), 3)
assert.fails(lambda: int(3, base=10), "non-string with explicit base")
# int from string, base implicitly 10
assert.eq(int("100000000000000000000"), 10000000000 * 10000000000)
assert.eq(int("-100000000000000000000"), -10000000000 * 10000000000)
assert.eq(int("123"), 123)
assert.eq(int("-123"), -123)
assert.eq(int("0123"), 123) # not octal
assert.eq(int("-0123"), -123)
assert.fails(lambda: int("0x12"), "invalid literal with base 10")
assert.fails(lambda: int("-0x12"), "invalid literal with base 10")
assert.fails(lambda: int("0o123"), "invalid literal.*base 10")
assert.fails(lambda: int("-0o123"), "invalid literal.*base 10")
# int from string, explicit base
assert.eq(int("11", base=9), 10)
assert.eq(int("-11", base=9), -10)
assert.eq(int("10011", base=2), 19)
assert.eq(int("-10011", base=2), -19)
assert.eq(int("123", 8), 83)
assert.eq(int("-123", 8), -83)
assert.eq(int("0123", 8), 83) # redundant zeros permittedd
assert.eq(int("-0123", 8), -83)
assert.eq(int("00123", 8), 83)
assert.eq(int("-00123", 8), -83)
assert.eq(int("0o123", 8), 83)
assert.eq(int("-0o123", 8), -83)
assert.eq(int("123", 7), 66) # 1*7*7 + 2*7 + 3
assert.eq(int("-123", 7), -66)
assert.eq(int("12", 16), 18)
assert.eq(int("-12", 16), -18)
assert.eq(int("0x12", 16), 18)
assert.eq(int("-0x12", 16), -18)
assert.fails(lambda: int("0x123", 8), "invalid literal.*base 8")
assert.fails(lambda: int("-0x123", 8), "invalid literal.*base 8")
assert.fails(lambda: int("0o123", 16), "invalid literal.*base 16")
assert.fails(lambda: int("-0o123", 16), "invalid literal.*base 16")
# int from string, auto detect base
assert.eq(int("123", 0), 123)
assert.eq(int("+123", 0), +123)
assert.eq(int("-123", 0), -123)
assert.eq(int("0x12", 0), 18)
assert.eq(int("+0x12", 0), +18)
assert.eq(int("-0x12", 0), -18)
assert.eq(int("0o123", 0), 83)
assert.eq(int("+0o123", 0), +83)
assert.eq(int("-0o123", 0), -83)
assert.fails(lambda: int("0123", 0), "invalid literal.*base 0") # valid in Python 2.7
assert.fails(lambda: int("-0123", 0), "invalid literal.*base 0")

# bitwise union (int|int) and intersection (int&int).
# TODO(adonovan): this is not yet in the Skylark spec,
# but there is consensus that it should be.
assert.eq(1|2, 3)
assert.eq(3|6, 7)
assert.eq((1|2) & (2|4), 2)

# comparisons
# TODO(adonovan): test: < > == != etc
assert.lt(-2, -1)
assert.lt(-1, 0)
assert.lt(0, 1)
assert.lt(1, 2)
assert.true(2 >= 2)
assert.true(2 > 1)
assert.true(1 >= 1)
assert.true(1 > 0)
assert.true(0 >= 0)
assert.true(0 > -1)
assert.true(-1 >= -1)
assert.true(-1 > -2)

# precision
maxint64 = 9223372036854775807 # = 2^63
minint64 = -maxint64 - 1       # = -2^64
assert.eq(str(maxint64), "9223372036854775807")
assert.eq(str(maxint64+1), "9223372036854775808")
assert.eq(str(minint64), "-9223372036854775808")
assert.eq(str(minint64-1), "-9223372036854775809")
assert.eq(str(minint64 * minint64), "85070591730234615865843651857942052864")

# string formatting
assert.eq("%o %x %d" % (0o755, 0xDEADBEEF, 42), "755 deadbeef 42")
nums = [-95, -1, 0, +1, +95]
assert.eq(' '.join(["%o" % x for x in nums]), "-137 -1 0 1 137")
assert.eq(' '.join(["%d" % x for x in nums]), "-95 -1 0 1 95")
assert.eq(' '.join(["%i" % x for x in nums]), "-95 -1 0 1 95")
assert.eq(' '.join(["%x" % x for x in nums]), "-5f -1 0 1 5f")
assert.eq(' '.join(["%X" % x for x in nums]), "-5F -1 0 1 5F")
assert.eq("%o %x %d" % (123, 123, 123), "173 7b 123")
assert.eq("%o %x %d" % (123.1, 123.1, 123.1), "173 7b 123") # non-int operands are acceptable
assert.fails(lambda: "%d" % True, "cannot convert bool to int")
